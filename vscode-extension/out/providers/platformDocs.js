"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BslPlatformDocsProvider = exports.PlatformDocItem = void 0;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
/**
 * –≠–ª–µ–º–µ–Ω—Ç –¥–µ—Ä–µ–≤–∞ –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–º–∏ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏
 */
class PlatformDocItem extends vscode.TreeItem {
    constructor(label, collapsibleState, version, contextValue, typesCount, archiveName, lastParsed) {
        super(label, collapsibleState);
        this.label = label;
        this.collapsibleState = collapsibleState;
        this.version = version;
        this.typesCount = typesCount;
        this.archiveName = archiveName;
        this.lastParsed = lastParsed;
        if (contextValue) {
            this.contextValue = contextValue;
        }
        if (version && contextValue === 'version') {
            this.tooltip = `Platform ${version}: ${typesCount || '?'} types`;
        }
    }
}
exports.PlatformDocItem = PlatformDocItem;
/**
 * Provider –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
 */
class BslPlatformDocsProvider {
    constructor(outputChannel) {
        this._onDidChangeTreeData = new vscode.EventEmitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.outputChannel = outputChannel;
    }
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (!element) {
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏–∑ –∫–µ—à–∞
            return this.getAvailablePlatformVersions();
        }
        else {
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –≤–µ—Ä—Å–∏–∏
            const details = [];
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∏–ø–æ–≤
            details.push(new PlatformDocItem(`üìä Types: ${element.typesCount || 'Unknown'}`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞—Ä—Ö–∏–≤–∞—Ö
            if (element.archiveName === 'Both archives') {
                details.push(new PlatformDocItem(`‚úÖ Status: Complete (shcntx + shlang)`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
                details.push(new PlatformDocItem(`üìÇ Archive: shcntx_ru.zip`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
                details.push(new PlatformDocItem(`üìÇ Archive: shlang_ru.zip`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            }
            else if (element.archiveName && element.archiveName.includes('shcntx')) {
                details.push(new PlatformDocItem(`üìÇ Archive: ${element.archiveName}`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
                details.push(new PlatformDocItem(`‚ö†Ô∏è Missing: shlang_ru.zip (primitive types)`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            }
            else if (element.archiveName && element.archiveName.includes('shlang')) {
                details.push(new PlatformDocItem(`üìÇ Archive: ${element.archiveName}`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
                details.push(new PlatformDocItem(`‚ö†Ô∏è Missing: shcntx_ru.zip (object types)`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            }
            else {
                details.push(new PlatformDocItem(`üì¶ Archive: ${element.archiveName || 'Unknown'}`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            }
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∞—Ç—É –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
            details.push(new PlatformDocItem(`üïí Added: ${element.lastParsed || 'Unknown'}`, vscode.TreeItemCollapsibleState.None, element.version, 'info'));
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —É–¥–∞–ª–µ–Ω–∏—è
            const removeItem = new PlatformDocItem(`üóëÔ∏è Remove this version`, vscode.TreeItemCollapsibleState.None, element.version, 'remove-version');
            removeItem.command = {
                command: 'bslAnalyzer.removePlatformDocs',
                title: 'Remove Platform Documentation',
                arguments: [element]
            };
            details.push(removeItem);
            return Promise.resolve(details);
        }
    }
    async getAvailablePlatformVersions() {
        const items = [];
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–µ—à–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ–Ω–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
        const homedir = require('os').homedir();
        const cacheDir = path.join(homedir, '.bsl_analyzer', 'platform_cache');
        if (fs.existsSync(cacheDir)) {
            // –ß–∏—Ç–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤–µ—Ä—Å–∏–π –∏–∑ –∫–µ—à–∞
            const files = fs.readdirSync(cacheDir);
            // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –æ–±–∞ —Ñ–æ—Ä–º–∞—Ç–∞: —Å –ø—Ä–µ—Ñ–∏–∫—Å–æ–º "v" –∏ –±–µ–∑ –Ω–µ–≥–æ
            const versionFiles = files.filter(f => f.match(/^v?[\d.]+\.jsonl$/));
            for (const versionFile of versionFiles) {
                const version = versionFile.replace(/^v/, '').replace('.jsonl', '');
                // –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∏–ø–æ–≤ –∏–∑ —Ñ–∞–π–ª–∞
                let typesCount = '?';
                let archiveInfo = 'Unknown';
                try {
                    const filePath = path.join(cacheDir, versionFile);
                    const content = fs.readFileSync(filePath, 'utf-8');
                    const lines = content.trim().split('\n');
                    typesCount = lines.length.toLocaleString();
                    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ –∞—Ä—Ö–∏–≤–æ–≤
                    let hasObjectTypes = false;
                    let hasPrimitiveTypes = false;
                    for (const line of lines.slice(0, 100)) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—ã–µ 100 —Å—Ç—Ä–æ–∫
                        try {
                            const entity = JSON.parse(line);
                            if (entity.name) {
                                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ–±—ä–µ–∫—Ç–Ω—ã–µ —Ç–∏–ø—ã (–∏–∑ shcntx)
                                if (entity.name.includes('–ú–∞—Å—Å–∏–≤') || entity.name.includes('Array') ||
                                    entity.name.includes('–¢–∞–±–ª–∏—Ü–∞–ó–Ω–∞—á–µ–Ω–∏–π') || entity.name.includes('ValueTable')) {
                                    hasObjectTypes = true;
                                }
                                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã (–∏–∑ shlang)
                                if (entity.name === '–ß–∏—Å–ª–æ' || entity.name === 'Number' ||
                                    entity.name === '–°—Ç—Ä–æ–∫–∞' || entity.name === 'String' ||
                                    entity.name === '–ë—É–ª–µ–≤–æ' || entity.name === 'Boolean') {
                                    hasPrimitiveTypes = true;
                                }
                            }
                        }
                        catch (e) {
                            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
                        }
                    }
                    if (hasObjectTypes && hasPrimitiveTypes) {
                        archiveInfo = 'Both archives';
                    }
                    else if (hasObjectTypes) {
                        archiveInfo = 'shcntx_ru.zip';
                    }
                    else if (hasPrimitiveTypes) {
                        archiveInfo = 'shlang_ru.zip';
                    }
                }
                catch (e) {
                    this.outputChannel?.appendLine(`Error reading platform cache: ${e}`);
                }
                const lastModified = fs.statSync(path.join(cacheDir, versionFile)).mtime.toLocaleDateString();
                // –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é
                this.outputChannel?.appendLine(`Found platform docs: v${version} - ${typesCount} types, archive: ${archiveInfo}`);
                items.push(new PlatformDocItem(`üìã Platform ${version} (${typesCount} types)`, vscode.TreeItemCollapsibleState.Expanded, version, 'version', typesCount, archiveInfo, lastModified));
            }
        }
        // –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
        const addDocsItem = new PlatformDocItem('‚ûï Add Platform Documentation...', vscode.TreeItemCollapsibleState.None, '', 'add-docs');
        addDocsItem.command = {
            command: 'bslAnalyzer.addPlatformDocs',
            title: 'Add Platform Documentation',
            arguments: []
        };
        items.push(addDocsItem);
        return items;
    }
}
exports.BslPlatformDocsProvider = BslPlatformDocsProvider;
//# sourceMappingURL=platformDocs.js.map