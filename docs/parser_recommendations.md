# Рекомендации по созданию парсера типов из SyntaxHelperContext (rebuilt.shcntx_ru.zip)

## Цели
- Извлечь типы свойств, параметров и возвращаемых значений методов платформы 1С.
- Нормализовать типы к каноническим идентификаторам (языковые и контекстные типы).
- Собрать маппинг RU/EN названий сущностей.

## Источники данных в архиве
- `objects/**/properties/*.html` — страницы свойств. Содержат «Тип: …».
- `objects/**/methods/*.html` — страницы методов. Содержат «Параметры:» (каждый с «Тип: …») и «Возвращаемое значение: Тип: …».
- `objects/**/<TypeName>.html` — страницы самих типов/классов/перечислений (например, `objects/catalog234/Array.html`).
- `objects/Global context.html` и `objects/Global context/**` — глобальный контекст, свойства и функции.
- `tables/**/fields/*.html` — типы полей таблиц метаданных (нужно только если анализируются типы хранилища/метаданных).
- Игнорировать для типов: корневые нумерованные файлы `0..87`, `IndexPackLookup` (индексы поиска), `*.st` (локализация/служебные), `__categories__`.

## Навигационные признаки в HTML
- Заголовок страницы: `h1.V8SH_pagetitle` — содержит RU и EN: `Имя.Член (English.Name)`.
- Заголовки разделов: `p.V8SH_chapter` со значениями `Синтаксис:`, `Параметры:`, `Возвращаемое значение:`, `Описание:`, `Доступность:`.
- Параметры: блоки `div.V8SH_rubric` с именем параметра; сразу после — строка вида `Тип: <a ...>…</a>`.
- Тип свойства/возврата: строка `Тип: ...` рядом с соответствующим разделом или сразу в теле страницы (часто перед `<br>` или до первой точки).
- Версии/устаревание: блоки с классами `__SINCE_SHOW_STYLE__`, `__DEPRECATED_SHOW_STYLE__`.

## Что извлекать
- Для свойств:
  - `owner` (объект), `name_ru`, `name_en` (из заголовка/путей), `types[]` (см. нормализацию), `read_only?` (по фразам «Чтение», «Запись»), `since`, `deprecated?`, `availability[]` (из «Доступность:»).
- Для методов:
  - `owner`, `name_ru`, `name_en`, `params[]` (имя, обязательность, `types[]`, краткое описание), `returns.types[]`, `since`, `deprecated?`, `availability[]`.
- Для типов/классов/перечислений (страницы типа):
  - `type_id` (канонический), `name_ru`, `name_en`, `category/path`, ссылки на свойства/методы (по необходимости).

## Нормализация типов
- Языковые базовые типы: ссылки вида `v8help://SyntaxHelperLanguage/def_*` → нормализуем к `language:def_String|def_Number|def_Boolean|def_Date|def_Undefined|def_Null|def_Type|...`.
- Контекстные/классы платформы: ссылки `v8help://SyntaxHelperContext/objects/.../*.html` → нормализуем к `context:objects/.../<Type>.html` (сохранять полный `href` как `type_id`).
- Составные/коллекции: типы вроде `Массив (Array)`, `Соответствие (Map)`, `СписокЗначений`, `ТаблицаЗначений` и т.п. — такие же `context`-ссылки.
- Ссылочные типы метаданных: строки вида `ПланВидовРасчетаСсылка.<Имя>` — сохранять как строковое представление, `kind=metadata_ref`, плюс исходный текст.
- Объединения типов: встречается перечисление через запятую или «или» (`Строка, Неопределено`). Разбивать на `union` (массив `types[]`).
- Отсутствие `<a>`: если после `Тип:` нет ссылки, разбирать текст (регекс, словарь соответствий RU → `type_id`).

## Правила парсинга «Тип: …»
- Общие:
  - Ищем текстовые узлы, начинающиеся с `Тип:` в пределах секции свойства/параметра/возврата.
  - Берем все `<a>` в этой строке как отдельные типы; если нет `<a>`, разбираем текст после `Тип:` до `<br>`/конца предложения.
  - Разделители: запятая, `или`.
- Параметры:
  - Имена параметров — из `div.V8SH_rubric` (внутри подписи вида `&lt;Имя&gt; (обязательный|необязательный)`).
  - Обязательность — по наличию `(обязательный)`/`(необязательный)`.
- Возврат:
  - В секции `Возвращаемое значение:` искать строку `Тип:` аналогично.

## Версии и доступность
- `since`: из блока `__SINCE_SHOW_STYLE__` («Доступен, начиная с версии …»).
- `deprecated`: из блока `__DEPRECATED_SHOW_STYLE__`.
- `availability[]`: из секции `Доступность:` — разбить по запятой на элементы («Сервер», «Тонкий клиент», «Веб‑клиент», …).

## Модель данных (предложение)
```
TypeRef {
  "id": "language:def_String" | "context:objects/catalog234/Array.html" | "metadata_ref:ПланВидовРасчетаСсылка",
  "name_ru": "Строка",
  "name_en": "String",
  "kind": "language" | "context" | "metadata_ref"
}

Parameter {
  "name": "Поле",
  "required": true,
  "types": [TypeRef, ...],
  "description": "Краткое описание при наличии"
}

Method {
  "owner": "DynamicList",
  "name_ru": "УстановитьОбязательноеИспользование",
  "name_en": "SetRequiredUse",
  "params": [Parameter, ...],
  "returns": { "types": [TypeRef, ...] },
  "since": "8.2",
  "deprecated": false,
  "availability": ["Сервер", "Веб‑клиент"]
}

Property {
  "owner": "DynamicList",
  "name_ru": "ВидКлюча",
  "name_en": "KeyType",
  "types": [TypeRef, ...],
  "read_only": false,
  "since": "8.3.14",
  "deprecated": false,
  "availability": ["Сервер"]
}
```

## Техническая реализация (рекомендация)
- Язык: Rust (в соответствии с проектом).
- Чтение архива: библиотека `zip` (стримовый проход без распаковки на диск).
- HTML-парсер: `scraper` (selectors API) или `kuchiki`/`html5ever`.
- Поиск файлов:
  - Свойства: `objects/**/properties/*.html`;
  - Методы: `objects/**/methods/*.html`;
  - Типы: `objects/**/[A-Za-z0-9_]+.html` на уровнях, где нет `properties/`/`methods/`.
- Производительность:
  - Однопроходный стрим по zip, фильтровать по путям.
  - Параллельный парс с `rayon` (соблюдать ограничение по памяти; парсить по одному файлу, агрегировать результаты).

## Разбор RU/EN
- Из `h1.V8SH_pagetitle`: парсить шаблон `RU (EN)` для объекта/члена.
- Из `*.st` при необходимости: брать RU/EN названия (не обязательно для типов).

## Обработка краевых случаев
- Нет ссылки после `Тип:` — маппинг по словарю RU (`Строка`, `Булево`, `Дата`, `Число`, `Неопределено`, `Null`, `Тип`, `Массив`, `Соответствие`, `СписокЗначений`, `ТаблицаЗначений`, …).
- Несколько `Тип:` в блоке — объединить типы (union).
- Текст «Тип: ЗначениеПеречисления …» — сохранять как `context`-ссылка, если присутствует `<a>`; иначе — текст с пометкой `enum_value`.
- Ссылочные типы метаданных (`…Ссылка.<Имя>`) — не нормализуются к `context`, оставить как `metadata_ref` с оригинальным текстом.

## Мини‑алгоритм извлечения для метода
1. Спарсить `h1.V8SH_pagetitle` → `owner`, `name_ru`, `name_en`.
2. Найти секцию `Параметры:` → для каждого `div.V8SH_rubric`:
   - Извлечь имя и обязательность;
   - В соседних узлах найти строку `Тип:` → извлечь ссылки/текст → нормализовать;
   - Извлечь краткое описание (если есть) до следующего параметра/раздела.
3. Найти секцию `Возвращаемое значение:` → извлечь `Тип:` аналогично.
4. Считать `since`, `deprecated`, `availability` из соответствующих блоков.

## Мини‑алгоритм извлечения для свойства
1. Спарсить `h1.V8SH_pagetitle` → `owner`, `name_ru`, `name_en`.
2. Найти ближайшую строку `Тип:` → извлечь и нормализовать типы.
3. Определить `read_only` по тексту «Чтение»/«Запись» в секции «Использование:» (если есть).
4. Считать `since`, `deprecated`, `availability` аналогично методам.

## Выходной формат
- Рекомендуется JSON‑каталог с тремя коллекциями: `types`, `properties`, `methods`.
- `types` формируется из страниц типов и всех встреченных `type_id` в ссылках.
- Хранить как минимум: `id`, `name_ru`, `name_en`, `kind`.

## Валидация и контроль качества
- Логировать все неизвестные текстовые типы (без ссылок) и расширять словарь.
- Проверять, что каждый `type_id` встречается в `types` или относится к `language:`/`metadata_ref`.
- Покрыть тестами выборку из `objects/catalog1649/catalog1614/DynamicList/**` и `objects/Global context/**`.

## Что точно можно не парсить для типов
- Корневые нумерованные файлы `0..87`, `IndexPackLookup` — индексы поиска.
- `*.st` — локализация/служебные данные.
- `__categories__` — навигационные файлы.

---

Если потребуется, можно дополнить описание конкретными CSS‑селекторами/регексами по итогам первичного прототипа.

