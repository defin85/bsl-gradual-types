# Иерархия типов функций в BSL

## Обзор

В BSL существует три различных типа функций/процедур, каждый из которых требует особой обработки в системе типов:

## 1. Глобальные функции платформы (Platform Global Functions)

**Примеры**: `Мин()`, `Макс()`, `Строка()`, `Сообщить()`, `ТекущаяДата()`

**Характеристики**:
- Встроены в платформу 1С:Предприятие
- Доступны глобально без импорта
- Часто полиморфны (работают с разными типами)
- Неизменяемы пользователем

**Хранение в системе типов**:
```rust
ConcreteType::GlobalFunction(GlobalFunction {
    name: "Мин",
    english_name: "Min",
    polymorphic: true,
    pure: true,
    // ...
})
```

**Источник данных**: Синтакс-помощник (`Global context/methods/`)

## 2. Методы объектов (Object Methods)

**Примеры**: `ТаблицаЗначений.Количество()`, `Справочник.НайтиПоКоду()`

**Характеристики**:
- Привязаны к конкретному типу объекта
- Вызываются через точку от экземпляра
- Могут изменять состояние объекта
- Определены платформой для каждого типа

**Хранение в системе типов**:
```rust
PlatformType {
    name: "ТаблицаЗначений",
    methods: vec![
        Method {
            name: "Количество",
            parameters: vec![],
            return_type: Some("Число"),
        }
    ],
    // ...
}
```

**Источник данных**: Синтакс-помощник (`objects/catalogXXX/TypeName/methods/`)

## 3. Пользовательские функции/процедуры (User-Defined Functions)

**Примеры**: 
```bsl
Функция ПолучитьЧтоТо(Параметр) Экспорт
    // Код функции
    Возврат Результат;
КонецФункции

Процедура ОбработатьДанные(Данные)
    // Код процедуры
КонецПроцедуры
```

**Характеристики**:
- Определены в коде пользователя
- Могут быть экспортными или локальными
- Типы параметров и возврата выводятся из использования
- Могут вызывать другие функции (создавая граф зависимостей)

**Хранение в системе типов**:

### В AST (Abstract Syntax Tree):
```rust
Statement::FunctionDecl {
    name: "ПолучитьЧтоТо",
    params: vec![Parameter { name: "Параметр", type_hint: None }],
    body: vec![/* statements */],
    return_value: Some(Expression),
    export: true,
}
```

### В графе зависимостей:
```rust
DependencyNode::Function {
    name: "ПолучитьЧтоТо",
    exported: true,
}
```

### В системе разрешения типов:
```rust
// Для экспортных функций модуля
ModuleFunction {
    module: "МойМодуль",
    name: "ПолучитьЧтоТо",
    signature: FunctionSignature {
        params: vec![/* inferred types */],
        return_type: TypeResolution::Inferred(0.8, /* type */),
    },
    visibility: Visibility::Export,
}
```

## Архитектурная интеграция

### Слоистая модель:

```
┌─────────────────────────────────────────┐
│            LSP Server                   │
│  (предлагает все три типа функций)      │
├─────────────────────────────────────────┤
│          Type Checker                   │
│  (выводит типы для user functions)      │
├─────────────────────────────────────────┤
│         Dependency Graph                │
│  (строит связи между user functions)    │
├─────────────────────────────────────────┤
│            BSL Parser                   │
│  (парсит user functions из кода)        │
├─────────────────────────────────────────┤
│        Platform Resolver                │
│  (загружает global и object methods)    │
└─────────────────────────────────────────┘
```

### Процесс анализа пользовательской функции:

1. **Парсинг** (BSL Parser):
   - Находит объявление функции в коде
   - Создаёт AST узел `FunctionDecl`
   - Извлекает параметры и тело функции

2. **Построение графа** (Dependency Graph):
   - Создаёт узел `DependencyNode::Function`
   - Анализирует вызовы других функций
   - Строит связи зависимостей

3. **Вывод типов** (Type Checker):
   - Анализирует использование параметров
   - Выводит типы из контекста вызовов
   - Определяет тип возвращаемого значения
   - Создаёт `TypeResolution` с уровнем уверенности

4. **Интеграция в LSP**:
   - Добавляет функцию в область видимости модуля
   - Предлагает в автодополнении с правильной сигнатурой
   - Показывает выведенные типы в hover

## Пример полного цикла

```bsl
// Модуль обработки
Функция ПолучитьСуммуЗаказа(Заказ) Экспорт
    Сумма = 0;
    Для Каждого Строка Из Заказ.Товары Цикл
        Сумма = Сумма + Строка.Количество * Строка.Цена;
    КонецЦикла;
    Возврат Сумма;
КонецФункции
```

**Анализ системой типов**:

1. Парсер создаёт AST с `FunctionDecl`
2. Из использования `Заказ.Товары` выводится, что `Заказ` - документ с табличной частью
3. Из операций `+` и `*` выводится, что `Сумма` - число
4. Создаётся сигнатура:
   ```rust
   FunctionSignature {
       params: vec![
           ("Заказ", TypeResolution::Inferred(0.9, DocumentRef("Заказ")))
       ],
       return_type: TypeResolution::Known(Primitive(Number))
   }
   ```
5. LSP предлагает: `ПолучитьСуммуЗаказа(Заказ: ДокументСсылка.Заказ): Число`

## Различия в обработке

| Аспект | Global Functions | Object Methods | User Functions |
|--------|-----------------|----------------|----------------|
| Источник | Синтакс-помощник | Синтакс-помощник | BSL код |
| Типы | Заранее известны | Заранее известны | Выводятся |
| Область видимости | Глобальная | Объект | Модуль/Локальная |
| Изменяемость | Нет | Нет | Да |
| Граф зависимостей | Не участвует | Не участвует | Участвует |
| Полиморфизм | Часто | Редко | Возможен |

## Рекомендации по реализации

1. **Не смешивать** три типа функций в одной структуре
2. **Использовать разные CompletionKind** в LSP для каждого типа
3. **Кешировать** платформенные функции, но не пользовательские
4. **Отслеживать изменения** только для пользовательских функций
5. **Выводить типы** инкрементально при изменении кода

## Связанные документы

- [Global Functions Architecture](global_functions.md) - детали о глобальных функциях
- [Type Inference](../design/type_inference.md) - алгоритмы вывода типов
- [Dependency Analysis](../design/dependency_analysis.md) - анализ зависимостей